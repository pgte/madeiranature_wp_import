(function() {
  var Valve;

  Valve = require('../');

  module.exports = {
    simple: function(æ) {
      var passed, readable, writable;
      writable = new Valve;
      readable = new Valve;
      passed = false;
      writable.on('pipe', function(src) {
        æ.equal(src, readable);
        return passed = true;
      });
      writable.on('end', function() {
        æ.equal(passed, true);
        return æ.done();
      });
      readable.pipe(writable);
      return readable.end();
    },
    multi: function(æ) {
      var check_done, chunkCount, chunkSize, closed_readables, closed_writables, count, data, i, nr, readable, readables, writable, writables, _ref;
      count = nr = 10;
      chunkSize = 250;
      chunkCount = 1000;
      closed_readables = 0;
      closed_writables = 0;
      _ref = [[], []], writables = _ref[0], readables = _ref[1];
      check_done = function() {
        if (closed_readables === nr && closed_writables === nr) return æ.done();
      };
      for (i = 0; 0 <= chunkSize ? i < chunkSize : i > chunkSize; 0 <= chunkSize ? i++ : i--) {
        chunkSize[i] = i % 256;
      }
      data = new Buffer(chunkSize);
      for (i = 0; 0 <= count ? i < count : i > count; 0 <= count ? i++ : i--) {
        readable = new Valve;
        readable.on('close', function() {
          closed_readables++;
          return check_done();
        });
        readables.push(readable);
        writable = new Valve;
        writable._got_data = 0;
        writable.on('data', function(chunk) {
          æ.equal(chunk, data);
          return this._got_data++;
        });
        writable.on('close', function() {
          æ.equal(this._got_data, chunkCount);
          closed_writables++;
          return check_done();
        });
        writables.push(writable);
        readable.ID = writable.ID = i;
        readable.pipe(writable);
      }
      return readables.forEach(function(readable) {
        var cnt, step;
        cnt = chunkCount;
        readable.on('resume', function() {
          return step();
        });
        step = function() {
          if (cnt > 0) readable.emit('data', data);
          if (--cnt === 0) {
            readable.end();
            if (--count === 0) {
              æ.equal(closed_readables, nr);
              æ.equal(closed_writables, nr);
            }
          }
          if (!(readable.paused || readable.finished)) {
            return process.nextTick(step);
          }
        };
        return process.nextTick(step);
      });
    }
  };

}).call(this);
