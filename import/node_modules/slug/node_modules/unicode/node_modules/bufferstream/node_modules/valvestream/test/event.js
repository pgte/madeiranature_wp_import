(function() {
  var DummySink, DummySource, EventEmitter, Steam, Valve;
  var __hasProp = Object.prototype.hasOwnProperty, __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor; child.__super__ = parent.prototype; return child; };

  EventEmitter = require('events').EventEmitter;

  Steam = require('stream').Stream;

  Valve = require('../');

  DummySink = (function() {

    __extends(DummySink, EventEmitter);

    function DummySink() {
      DummySink.__super__.constructor.apply(this, arguments);
    }

    DummySink.prototype.writable = true;

    DummySink.prototype.write = function(data) {
      this.emit('data', data);
      if (this.used_once) return true;
      setTimeout(this.emit.bind(this, 'drain'), 20);
      this.used_once = true;
      return false;
    };

    DummySink.prototype.end = function() {
      return this.emit('end');
    };

    return DummySink;

  })();

  DummySource = (function() {

    __extends(DummySource, Steam);

    function DummySource() {
      DummySource.__super__.constructor.apply(this, arguments);
    }

    DummySource.prototype.readable = true;

    DummySource.prototype.write = function(data) {
      return this.emit('data', data);
    };

    DummySource.prototype.end = function() {
      return this.emit('end');
    };

    return DummySource;

  })();

  module.exports = {
    'mutli source': function(æ) {
      var chunkSize, drains, i, pauses, payload, received, resumes, sink, source, sources, valve, _i, _j, _len, _len2;
      chunkSize = 250;
      received = 0;
      resumes = 0;
      pauses = 0;
      drains = 0;
      for (i = 0; 0 <= chunkSize ? i < chunkSize : i > chunkSize; 0 <= chunkSize ? i++ : i--) {
        chunkSize[i] = i % 256;
      }
      payload = new Buffer(chunkSize);
      sink = new DummySink;
      valve = new Valve;
      sources = [new DummySource, new DummySource, new DummySource];
      valve.on('drain', function() {
        return drains++;
      });
      valve.on('pause', function() {
        return pauses++;
      });
      valve.on('resume', function() {
        return resumes++;
      });
      sink.on('data', function(data) {
        æ.equal(data, payload);
        return received++;
      });
      sink.on('end', function() {
        æ.equal(received, 1);
        æ.equal(resumes, 1);
        æ.equal(pauses, 1);
        æ.equal(drains, 1);
        return æ.done();
      });
      for (_i = 0, _len = sources.length; _i < _len; _i++) {
        source = sources[_i];
        source.pipe(valve);
      }
      valve.pipe(sink);
      for (_j = 0, _len2 = sources.length; _j < _len2; _j++) {
        source = sources[_j];
        source.write(payload);
      }
      return setTimeout(function() {
        var source, _k, _len3, _results;
        _results = [];
        for (_k = 0, _len3 = sources.length; _k < _len3; _k++) {
          source = sources[_k];
          _results.push(source.end());
        }
        return _results;
      }, 100);
    }
  };

}).call(this);
