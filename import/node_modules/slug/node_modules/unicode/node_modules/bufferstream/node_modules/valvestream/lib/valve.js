(function() {
  var Steam, Valve, weak, weakreference;
  var __hasProp = Object.prototype.hasOwnProperty, __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor; child.__super__ = parent.prototype; return child; };

  Steam = require('stream').Stream;

  try {
    weak = require('weak');
  } catch (nothing) {

  }

  weakreference = function(list, obj) {
    var ref;
    var _this = this;
    ref = typeof weak === "function" ? weak(obj, function() {
      var i;
      i = list.indexOf(ref);
      if (i === -1) return;
      return list = list.slice(0, i).concat(list.slice(i + 1));
    }) : void 0;
    if (ref == null) ref = obj;
    return list.push(ref);
  };

  Valve = (function() {

    __extends(Valve, Steam);

    function Valve(opts) {
      var _ref, _ref2, _ref3, _ref4, _ref5, _ref6, _ref7, _ref8, _ref9;
      if (opts == null) opts = {};
      if (typeof opts === 'string') {
        opts = {
          encoding: opts
        };
      }
      this.useweak = (_ref = opts.weak) != null ? _ref : false;
      if ((_ref2 = this.sources) == null) this.sources = [];
      if ((_ref3 = this.sinks) == null) this.sinks = [];
      this.setEncoding((_ref4 = opts.encoding) != null ? _ref4 : null);
      if ((_ref5 = this.finished) == null) this.finished = false;
      if ((_ref6 = this.paused) == null) this.paused = false;
      if ((_ref7 = this.writable) == null) this.writable = false;
      if ((_ref8 = this.readable) == null) this.readable = true;
      if ((_ref9 = this.jammed) == null) this.jammed = 0;
      this.on('pipe', function(source) {
        if (this.encoding != null) {
          if (typeof source.setEncoding === "function") {
            source.setEncoding(this.encoding);
          }
        }
        if (this.paused) source.pause();
        this.writable = true;
        if (this.useweak) {
          return weakreference(this.sources, source);
        } else {
          return this.sources.push(source);
        }
      });
      Valve.__super__.constructor.apply(this, arguments);
    }

    Valve.prototype.emit = function(event, data) {
      if (event !== 'data') return Valve.__super__.emit.apply(this, arguments);
      return this.flush(data, this.encoding);
    };

    Valve.prototype.pause = function() {
      var source, _i, _len, _ref;
      if (this.paused) return;
      this.paused = true;
      _ref = this.sources;
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        source = _ref[_i];
        if (source.readable) {
          if (typeof source.pause === "function") source.pause();
        }
      }
      return this.emit('pause');
    };

    Valve.prototype.resume = function() {
      var source, _i, _len, _ref;
      if (!this.paused) return;
      if (this.jammed > 0) this.jammed--;
      if (this.jammed !== 0) return;
      this.emit('drain');
      this.paused = false;
      _ref = this.sources;
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        source = _ref[_i];
        if (source.readable) {
          if (typeof source.resume === "function") source.resume();
        }
      }
      this.emit('resume');
      if (this.finished) {
        this.emit('end');
        return this.emit('close');
      }
    };

    Valve.prototype.setEncoding = function(encoding) {
      var source, _i, _len, _ref;
      this.encoding = encoding;
      _ref = this.sources;
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        source = _ref[_i];
        if (typeof source.setEncoding === "function") {
          source.setEncoding(this.encoding);
        }
      }
      return this.encoding;
    };

    Valve.prototype.flush = function(data, encoding) {
      var clear, sink, wantsmore, _i, _len, _ref;
      if (this.paused || this.jammed !== 0) return false;
      _ref = this.sinks;
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        sink = _ref[_i];
        if (!sink.writable) continue;
        wantsmore = sink.write(data, encoding);
        if (wantsmore === false) this.jammed++;
      }
      Valve.__super__.emit.call(this, 'data', data);
      clear = this.jammed === 0;
      if (!clear) this.pause();
      return clear;
    };

    Valve.prototype.write = function() {
      if (!this.writable) {
        this.emit('error', new Error("Stream is not writable."));
        return false;
      }
      return this.flush.apply(this, arguments);
    };

    Valve.prototype.end = function(data, encoding) {
      if (this.finished) return;
      this.finished = true;
      if (data != null) this.write(data, encoding);
      this.writable = false;
      if (!this.paused) {
        this.emit('end');
        return this.emit('close');
      }
    };

    Valve.prototype.destroy = function() {
      var sink, source, _i, _j, _len, _len2, _ref, _ref2, _results;
      _ref = this.sources;
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        source = _ref[_i];
        source.destroy();
      }
      _ref2 = this.sinks;
      _results = [];
      for (_j = 0, _len2 = _ref2.length; _j < _len2; _j++) {
        sink = _ref2[_j];
        _results.push(sink.destroy());
      }
      return _results;
    };

    Valve.prototype.destroySoon = function() {
      var sink, source, _i, _j, _len, _len2, _ref, _ref2, _results;
      _ref = this.sources;
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        source = _ref[_i];
        source.destroy();
      }
      _ref2 = this.sinks;
      _results = [];
      for (_j = 0, _len2 = _ref2.length; _j < _len2; _j++) {
        sink = _ref2[_j];
        _results.push(sink.destroySoon());
      }
      return _results;
    };

    Valve.prototype.pipe = function(sink, opts) {
      var cleanup, didOnEnd, onclose, ondrain, onend, onerror, source;
      if (opts == null) opts = {};
      source = this;
      this.writable = true;
      if (this.useweak) {
        weakreference(this.sinks, sink);
      } else {
        this.sinks.push(sink);
      }
      didOnEnd = false;
      onend = function() {
        if (didOnEnd) return;
        didOnEnd = true;
        cleanup();
        return sink.end();
      };
      onclose = function() {
        if (didOnEnd) return;
        didOnEnd = true;
        cleanup();
        return sink.destroy();
      };
      onerror = function(err) {
        cleanup();
        if (this.listeners('error').length === 0) throw err;
      };
      source.on('error', onerror);
      sink.on('error', onerror);
      if (!sink._isStdio && opts.end !== false) {
        source.on('close', onclose);
        source.on('end', onend);
      }
      ondrain = function() {
        return source.resume();
      };
      sink.on('drain', ondrain);
      cleanup = function() {
        sink.removeListener('drain', ondrain);
        source.removeListener('end', onend);
        source.removeListener('close', onclose);
        source.removeListener('error', onerror);
        sink.removeListener('error', onerror);
        source.removeListener('end', cleanup);
        source.removeListener('close', cleanup);
        sink.removeListener('end', cleanup);
        return sink.removeListener('close', cleanup);
      };
      source.on('end', cleanup);
      source.on('close', cleanup);
      sink.on('end', cleanup);
      sink.on('close', cleanup);
      sink.emit('pipe', source);
      return sink;
    };

    return Valve;

  })();

  module.exports = Valve;

}).call(this);
