(function() {
  var BufferStream, Valve, fn, isArray, isBuffer, split, _ref;
  var __bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; }, __hasProp = Object.prototype.hasOwnProperty, __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor; child.__super__ = parent.prototype; return child; }, __slice = Array.prototype.slice;

  Valve = require('valvestream');

  fn = require('./fn');

  _ref = [Array.isArray, Buffer.isBuffer], isArray = _ref[0], isBuffer = _ref[1];

  split = function() {
    var buflen, can_split, cur, found, i, pos, rest, splitter, _i, _len, _ref2, _ref3, _results;
    if (!this.buffer.length) return;
    can_split = this.enabled && this.splitters.length;
    _results = [];
    while (can_split) {
      cur = null;
      pos = buflen = this.buffer.length;
      _ref2 = this.splitters;
      for (_i = 0, _len = _ref2.length; _i < _len; _i++) {
        splitter = _ref2[_i];
        if (buflen < splitter.length) continue;
        i = fn.indexOf.call(this.buffer, splitter);
        if (i !== -1 && i < pos && i < buflen) {
          cur = splitter;
          pos = i;
        }
      }
      can_split = cur !== null;
      if (!can_split) break;
      _ref3 = fn.split(this.buffer, pos, cur.length), found = _ref3[0], rest = _ref3[1];
      this.buffer = rest;
      this.emit('split', found, cur);
      if (!this.enabled || this.buffer.length === 0) {
        break;
      } else {
        _results.push(void 0);
      }
    }
    return _results;
  };

  BufferStream = (function() {

    __extends(BufferStream, Valve);

    function BufferStream(opts) {
      var _ref2;
      var _this = this;
      if (opts == null) opts = {};
      this.reset = __bind(this.reset, this);
      this.clear = __bind(this.clear, this);
      this.write = __bind(this.write, this);
      this.split = __bind(this.split, this);
      this.disable = __bind(this.disable, this);
      this.enable = __bind(this.enable, this);
      this.setSize = __bind(this.setSize, this);
      this.toString = __bind(this.toString, this);
      this.getBuffer = __bind(this.getBuffer, this);
      if (typeof opts === 'string') {
        opts = {
          encoding: opts
        };
      }
      if ((_ref2 = opts.size) == null) opts.size = 'none';
      this.size = opts.size;
      this.splitters = [];
      this.__defineGetter__('length', function() {
        return _this.buffer.length;
      });
      this.enabled = true;
      this.writable = false;
      if (this.size === 'flexible') this.writable = true;
      this.reset();
      BufferStream.__super__.constructor.call(this, opts);
      if (opts.split != null) {
        if (isArray(opts.split)) {
          this.split(opts.split);
        } else {
          this.split(opts.split, function(data) {
            return this.emit('data', data);
          });
        }
      }
      if (opts.disabled) this.disable();
    }

    BufferStream.prototype.getBuffer = function() {
      return this.buffer;
    };

    BufferStream.prototype.toString = function() {
      return this.buffer.toString();
    };

    BufferStream.prototype.setSize = function(size) {
      this.size = size;
      if (!this.paused && this.size === 'none') return this.clear();
    };

    BufferStream.prototype.enable = function() {
      return this.enabled = true;
    };

    BufferStream.prototype.disable = function() {
      var args, i, splitter, _i, _len;
      args = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
      if (args.length === 1 && isArray(args[0])) args = args[0];
      for (_i = 0, _len = args.length; _i < _len; _i++) {
        splitter = args[_i];
        i = this.splitters.indexOf(splitter);
        if (i === -1) continue;
        this.splitters = this.splitters.slice(0, i).concat(this.splitters.slice(i + 1));
        if (!this.splitters.length) break;
      }
      if (!this.splitters.length) this.enabled = false;
      if (!args.length) {
        this.enabled = false;
        if (!this.paused) return this.clear();
      }
    };

    BufferStream.prototype.split = function() {
      var args, callback, splitter;
      args = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
      if (args.length === 1 && isArray(args[0])) args = args[0];
      if (args.length === 2 && typeof args[1] === 'function') {
        splitter = args[0], callback = args[1];
        this.splitters.push(splitter);
        return this.on('split', function(_, token) {
          if (token === splitter) return callback.apply(this, arguments);
        });
      }
      return this.splitters = this.splitters.concat(args);
    };

    BufferStream.prototype.write = function(buffer, encoding) {
      if (!this.writable) {
        this.emit('error', new Error("Stream is not writable."));
        return false;
      }
      if (isBuffer(buffer)) {} else if (typeof buffer === 'string') {
        buffer = new Buffer(buffer, encoding != null ? encoding : this.encoding);
      } else {
        this.emit('error', new Error("Argument should be either a buffer or a string."));
      }
      if (this.buffer.length === 0) {
        this.buffer = buffer;
      } else {
        this.buffer = fn.concat(this.buffer, buffer);
      }
      if (this.size === 'flexible') {
        if (this.enabled) {
          split.call(this);
          if (this.finished) return this.clear();
          return true;
        } else {
          return this.clear();
        }
      } else if (this.size === 'none') {
        if (this.enabled) this.buffer = split.call(this);
        return this.clear();
      } else {
        throw new Error("not implemented yet :(");
      }
    };

    BufferStream.prototype.clear = function() {
      var buffer;
      if (!this.buffer.length) return;
      buffer = this.buffer;
      this.reset();
      return this.flush(buffer);
    };

    BufferStream.prototype.reset = function() {
      if (typeof this.size === 'number') {
        return this.buffer = new Buffer(this.size);
      } else {
        return this.buffer = new Buffer(0);
      }
    };

    BufferStream.prototype.resume = function() {
      var source, _i, _len, _ref2;
      if (!this.paused || this.jammed === 0) return;
      this.jammed--;
      if (this.jammed !== 0) return;
      this.emit('drain');
      this.paused = false;
      if (!this.enabled || this.size === 'none' || this.finished) this.clear();
      _ref2 = this.sources;
      for (_i = 0, _len = _ref2.length; _i < _len; _i++) {
        source = _ref2[_i];
        if (source.readable) {
          if (typeof source.resume === "function") source.resume();
        }
      }
      if (this.size === 'none') this.emit('resume');
      if (this.finished) {
        this.emit('end');
        return this.emit('close');
      }
    };

    return BufferStream;

  })();

  BufferStream.fn = fn;

  module.exports = BufferStream;

}).call(this);
